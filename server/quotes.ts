
import { Router } from "express";
import { db } from "./db";
import { personalizedQuotes, leads, insertPersonalizedQuoteSchema } from "@shared/schema";
import { eq } from "drizzle-orm";
import { z } from "zod";
import { nanoid } from "nanoid";
import { openai } from "./openai";
import { generateValuePricingQuote, createAnalyticsLog, generateTierDeliverables } from "./value-pricing-engine";

// Define input schema for value pricing
const valuePricingInputSchema = z.object({
    jobDescription: z.string().min(10, 'Job description must be at least 10 characters'),
    baseJobPrice: z.number().positive('Base price must be positive'), // In pence
    urgencyReason: z.enum(['low', 'med', 'high']),
    ownershipContext: z.enum(['tenant', 'homeowner', 'landlord', 'airbnb', 'selling']),
    desiredTimeframe: z.enum(['flex', 'week', 'asap']),
    additionalNotes: z.string().optional(),
    customerName: z.string().min(1, 'Customer name is required'),
    phone: z.string().min(1, 'Phone number is required'),
    email: z.string().email().optional().or(z.literal('')),
    postcode: z.string().min(1, 'Postcode is required'),
    quoteMode: z.enum(['simple', 'hhh']).default('hhh'),
    analyzedJobData: z.any().optional(), // Pass through AI analysis data
    materialsCostWithMarkupPence: z.number().nonnegative().optional(), // Materials with markup
    optionalExtras: z.array(z.any()).optional(), // Optional extras for simple mode
    clientType: z.enum(['homeowner', 'landlord', 'commercial']).default('homeowner'), // New: Default to homeowner
    jobComplexity: z.enum(['trivial', 'low', 'medium', 'high']).default('low'), // New: Default to low
});

export const quotesRouter = Router();

// Create Quote Endpoint
quotesRouter.post('/api/personalized-quotes/value', async (req, res) => {
    try {
        const input = valuePricingInputSchema.parse(req.body);

        // Use nanoid for short slug if not generated by DB function
        const shortSlug = nanoid(8);
        const id = `quote_${nanoid()}`;

        // Generate quote using value pricing engine
        const pricingResult = generateValuePricingQuote({
            urgencyReason: input.urgencyReason,
            ownershipContext: input.ownershipContext,
            desiredTimeframe: input.desiredTimeframe,
            baseJobPrice: input.baseJobPrice,
            clientType: input.clientType,
            jobComplexity: input.jobComplexity,
        });

        // Generate tier deliverables
        const tierDeliverables = generateTierDeliverables(input.analyzedJobData, input.jobDescription);

        // Prepare quote data
        const quoteInsertData = {
            id,
            shortSlug,
            customerName: input.customerName,
            phone: input.phone,
            email: input.email || null,
            postcode: input.postcode,
            jobDescription: input.jobDescription,
            quoteMode: input.quoteMode,

            // HHH Mode Prices
            essentialPrice: input.quoteMode === 'hhh' ? pricingResult.essential.price : null,
            enhancedPrice: input.quoteMode === 'hhh' ? pricingResult.hassleFree.price : null,
            elitePrice: input.quoteMode === 'hhh' ? pricingResult.highStandard.price : null,

            // Simple Mode Prices
            basePrice: input.quoteMode === 'simple' ? pricingResult.essential.price : null,

            // Context & Inputs
            urgencyReason: input.urgencyReason,
            ownershipContext: input.ownershipContext,
            desiredTimeframe: input.desiredTimeframe,
            baseJobPricePence: input.baseJobPrice,
            valueMultiplier100: Math.round(pricingResult.valueMultiplier * 100),
            recommendedTier: pricingResult.recommendedTier,
            additionalNotes: input.additionalNotes || null,

            // Metadata
            jobs: input.analyzedJobData ? [input.analyzedJobData] : null,
            tierDeliverables: {
                essential: tierDeliverables.essential,
                hassleFree: tierDeliverables.hassleFree,
                highStandard: tierDeliverables.highStandard,
            },
            materialsCostWithMarkupPence: input.materialsCostWithMarkupPence || 0,
            optionalExtras: input.optionalExtras || null,

            createdAt: new Date(),
        };

        // Insert into DB
        await db.insert(personalizedQuotes).values(quoteInsertData);

        // Response
        const responsePayload = {
            ...quoteInsertData,
            valueMultiplier: pricingResult.valueMultiplier,
            recommendedTier: pricingResult.recommendedTier,
            essential: input.quoteMode === 'hhh' ? {
                price: pricingResult.essential.price,
                perks: pricingResult.essential.perks,
                warrantyMonths: pricingResult.essential.warrantyMonths,
                isRecommended: pricingResult.essential.isRecommended,
            } : undefined,
            hassleFree: input.quoteMode === 'hhh' ? {
                price: pricingResult.hassleFree.price,
                perks: pricingResult.hassleFree.perks,
                warrantyMonths: pricingResult.hassleFree.warrantyMonths,
                isRecommended: pricingResult.hassleFree.isRecommended,
            } : undefined,
            highStandard: input.quoteMode === 'hhh' ? {
                price: pricingResult.highStandard.price,
                perks: pricingResult.highStandard.perks,
                warrantyMonths: pricingResult.highStandard.warrantyMonths,
                isRecommended: pricingResult.highStandard.isRecommended,
            } : undefined,
            basePrice: input.quoteMode === 'simple' ? pricingResult.essential.price : undefined,
        };

        res.status(201).json(responsePayload);

    } catch (error: any) {
        console.error('Error creating quote:', error);
        if (error instanceof z.ZodError) {
            return res.status(400).json({ message: 'Invalid input', errors: error.errors });
        }
        res.status(500).json({ message: `Failed to create quote: ${error.message || 'Unknown error'}` });
    }
});

// Analyze Job Endpoint
quotesRouter.post('/api/analyze-job', async (req, res) => {
    try {
        const { jobDescription } = req.body;
        if (!jobDescription) return res.status(400).json({ error: "Job description is required" });

        const response = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: [
                {
                    role: "system",
                    content: `Analyze this handyman job description. Return JSON with:
                    - totalEstimatedHours (number)
                    - basePricePounds (number, estimate at £50/hr + £40 callout)
                    - summary (string, professional summary)
                    - tasks (array of objects with description, estimatedHours)
                    `
                },
                {
                    role: "user",
                    content: jobDescription
                }
            ],
            response_format: { type: "json_object" }
        });

        const result = JSON.parse(response.choices[0].message.content || "{}");
        res.json(result);

    } catch (error: any) {
        console.error("Job analysis error:", error?.message || error);
        console.error("Full error:", JSON.stringify(error, null, 2));
        res.status(500).json({ error: "Analysis failed", details: error?.message || "Unknown error" });
    }
});

// Parse Optional Extra
quotesRouter.post('/api/parse-optional-extra', async (req, res) => {
    try {
        const { extraDescription } = req.body;
        if (!extraDescription) return res.status(400).json({ error: "Description required" });

        const response = await openai.chat.completions.create({
            model: "gpt-4o-mini",
            messages: [
                {
                    role: "system",
                    content: "Extract optional extra details: label, description, priceInPence (estimate), estimatedHours, materialsCost."
                },
                {
                    role: "user",
                    content: `Extract details for: ${extraDescription}`
                }
            ],
            response_format: { type: "json_object" }
        });

        const result = JSON.parse(response.choices[0].message.content || "{}");
        // Ensure defaults
        const cleanResult = {
            label: result.label || "Extra",
            description: result.description || extraDescription,
            priceInPence: result.priceInPence || 5000,
            estimatedHours: result.estimatedHours || 1,
            materialsCost: result.materialsCost || 0,
            serviceType: 'general',
            complexity: 'moderate'
        };

        res.json(cleanResult);
    } catch (error) {
        console.error("Parse extra error:", error);
        res.status(500).json({ error: "Parsing failed" });
    }
});

// Recalculate Optional Extra Price
quotesRouter.post('/api/recalculate-optional-extra', async (req, res) => {
    try {
        const { serviceType, complexity, estimatedHours, materialsCost } = req.body;

        // Simple calculation logic without AI for speed
        const baseRate = 5000; // £50/hr
        const complexityMultipliers: Record<string, number> = {
            'trivial': 0.8, 'low': 0.9, 'moderate': 1.0, 'medium': 1.0,
            'high': 1.25, 'complex': 1.5, 'very_complex': 2.0
        };

        const multiplier = complexityMultipliers[complexity as string] || 1.0;
        const laborCostInPence = Math.round(estimatedHours * baseRate * multiplier);
        const materialsCostInPence = Math.round((materialsCost || 0) * 100); // input is pounds, store Pence
        const calloutFeeInPence = 0; // Optional Extras usually done while on site

        const priceInPence = laborCostInPence + materialsCostInPence;

        res.json({
            serviceType,
            complexity,
            estimatedHours,
            materialsCost,
            priceInPence,
            materialsCostInPence,
            laborCostInPence,
            calloutFeeInPence
        });

    } catch (error) {
        console.error("Recalculate extra error:", error);
        res.status(500).json({ error: "Recalculation failed" });
    }
});

// Get Quote by Slug
quotesRouter.get('/api/personalized-quotes/:slug', async (req, res) => {
    try {
        const { slug } = req.params;
        const result = await db.select().from(personalizedQuotes).where(eq(personalizedQuotes.shortSlug, slug)).limit(1);
        const quote = result[0];

        if (!quote) {
            return res.status(404).json({ error: "Quote not found" });
        }

        // Track first view - update viewedAt if not already set
        if (!quote.viewedAt) {
            const now = new Date();
            await db.update(personalizedQuotes)
                .set({ viewedAt: now })
                .where(eq(personalizedQuotes.id, quote.id));

            // Return updated quote with viewedAt
            res.json({ ...quote, viewedAt: now });
        } else {
            res.json(quote);
        }

    } catch (error) {
        console.error("Get quote error:", error);
        res.status(500).json({ error: "Failed to fetch quote" });
    }
});

