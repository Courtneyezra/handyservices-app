
import { Router } from "express";
import { db } from "./db";
import { personalizedQuotes, leads, insertPersonalizedQuoteSchema } from "@shared/schema";
import { eq, desc } from "drizzle-orm";
import { z } from "zod";
import { nanoid } from "nanoid";
import { openai } from "./openai";
import { generateValuePricingQuote, createAnalyticsLog, generateTierDeliverables } from "./value-pricing-engine";

// Define input schema for value pricing
const valuePricingInputSchema = z.object({
    jobDescription: z.string().min(10, 'Job description must be at least 10 characters'),
    baseJobPrice: z.number().positive('Base price must be positive'), // In pence
    urgencyReason: z.enum(['low', 'med', 'high']),
    ownershipContext: z.enum(['tenant', 'homeowner', 'landlord', 'airbnb', 'selling']),
    desiredTimeframe: z.enum(['flex', 'week', 'asap']),
    additionalNotes: z.string().optional(),
    customerName: z.string().min(1, 'Customer name is required'),
    phone: z.string().min(1, 'Phone number is required'),
    email: z.string().email().optional().or(z.literal('')),
    postcode: z.string().min(1, 'Postcode is required'),
    quoteMode: z.enum(['simple', 'hhh']).default('hhh'),
    analyzedJobData: z.any().optional(), // Pass through AI analysis data
    materialsCostWithMarkupPence: z.number().nonnegative().optional(), // Materials with markup
    optionalExtras: z.array(z.any()).optional(), // Optional extras for simple mode
    clientType: z.enum(['homeowner', 'landlord', 'commercial']).default('homeowner'), // New: Default to homeowner
    jobComplexity: z.enum(['trivial', 'low', 'medium', 'high']).default('low'), // New: Default to low
});

export const quotesRouter = Router();

// Create Quote Endpoint
quotesRouter.post('/api/personalized-quotes/value', async (req, res) => {
    try {
        const input = valuePricingInputSchema.parse(req.body);

        // Use nanoid for short slug if not generated by DB function
        const shortSlug = nanoid(8);
        const id = `quote_${nanoid()}`;

        // Generate quote using value pricing engine
        const pricingResult = generateValuePricingQuote({
            urgencyReason: input.urgencyReason,
            ownershipContext: input.ownershipContext,
            desiredTimeframe: input.desiredTimeframe,
            baseJobPrice: input.baseJobPrice,
            clientType: input.clientType,
            jobComplexity: input.jobComplexity,
        });

        // Generate tier deliverables
        const tierDeliverables = generateTierDeliverables(input.analyzedJobData, input.jobDescription);

        // Prepare quote data
        const quoteInsertData = {
            id,
            shortSlug,
            customerName: input.customerName,
            phone: input.phone,
            email: input.email || null,
            postcode: input.postcode,
            jobDescription: input.jobDescription,
            quoteMode: input.quoteMode,

            // HHH Mode Prices
            essentialPrice: input.quoteMode === 'hhh' ? pricingResult.essential.price : null,
            enhancedPrice: input.quoteMode === 'hhh' ? pricingResult.hassleFree.price : null,
            elitePrice: input.quoteMode === 'hhh' ? pricingResult.highStandard.price : null,

            // Simple Mode Prices
            basePrice: input.quoteMode === 'simple' ? pricingResult.essential.price : null,

            // Context & Inputs
            urgencyReason: input.urgencyReason,
            ownershipContext: input.ownershipContext,
            desiredTimeframe: input.desiredTimeframe,
            baseJobPricePence: input.baseJobPrice,
            valueMultiplier100: Math.round(pricingResult.valueMultiplier * 100),
            recommendedTier: pricingResult.recommendedTier,
            additionalNotes: input.additionalNotes || null,

            // Metadata
            jobs: input.analyzedJobData ? [input.analyzedJobData] : null,
            tierDeliverables: {
                essential: tierDeliverables.essential,
                hassleFree: tierDeliverables.hassleFree,
                highStandard: tierDeliverables.highStandard,
            },
            materialsCostWithMarkupPence: input.materialsCostWithMarkupPence || 0,
            optionalExtras: input.optionalExtras || null,

            createdAt: new Date(),
            expiresAt: new Date(Date.now() + 15 * 60 * 1000), // 15 minutes from creation
        };

        // Insert into DB
        await db.insert(personalizedQuotes).values(quoteInsertData);

        // Response
        const responsePayload = {
            ...quoteInsertData,
            valueMultiplier: pricingResult.valueMultiplier,
            recommendedTier: pricingResult.recommendedTier,
            essential: input.quoteMode === 'hhh' ? {
                price: pricingResult.essential.price,
                perks: pricingResult.essential.perks,
                warrantyMonths: pricingResult.essential.warrantyMonths,
                isRecommended: pricingResult.essential.isRecommended,
            } : undefined,
            hassleFree: input.quoteMode === 'hhh' ? {
                price: pricingResult.hassleFree.price,
                perks: pricingResult.hassleFree.perks,
                warrantyMonths: pricingResult.hassleFree.warrantyMonths,
                isRecommended: pricingResult.hassleFree.isRecommended,
            } : undefined,
            highStandard: input.quoteMode === 'hhh' ? {
                price: pricingResult.highStandard.price,
                perks: pricingResult.highStandard.perks,
                warrantyMonths: pricingResult.highStandard.warrantyMonths,
                isRecommended: pricingResult.highStandard.isRecommended,
            } : undefined,
            basePrice: input.quoteMode === 'simple' ? pricingResult.essential.price : undefined,
        };

        res.status(201).json(responsePayload);

    } catch (error: any) {
        console.error('Error creating quote:', error);
        if (error instanceof z.ZodError) {
            return res.status(400).json({ message: 'Invalid input', errors: error.errors });
        }
        res.status(500).json({ message: `Failed to create quote: ${error.message || 'Unknown error'}` });
    }
});

// Analyze Job Endpoint
quotesRouter.post('/api/analyze-job', async (req, res) => {
    try {
        const { jobDescription } = req.body;
        if (!jobDescription) return res.status(400).json({ error: "Job description is required" });

        const response = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: [
                {
                    role: "system",
                    content: `Analyze this handyman job description. Return JSON with:
                    - totalEstimatedHours (number)
                    - basePricePounds (number, estimate at £50/hr + £40 callout)
                    - summary (string, professional summary)
                    - tasks (array of objects with description, estimatedHours)
                    `
                },
                {
                    role: "user",
                    content: jobDescription
                }
            ],
            response_format: { type: "json_object" }
        });

        const result = JSON.parse(response.choices[0].message.content || "{}");
        res.json(result);

    } catch (error: any) {
        console.error("Job analysis error:", error?.message || error);
        console.error("Full error:", JSON.stringify(error, null, 2));
        res.status(500).json({ error: "Analysis failed", details: error?.message || "Unknown error" });
    }
});

// Parse Optional Extra
quotesRouter.post('/api/parse-optional-extra', async (req, res) => {
    try {
        const { extraDescription } = req.body;
        if (!extraDescription) return res.status(400).json({ error: "Description required" });

        const response = await openai.chat.completions.create({
            model: "gpt-4o-mini",
            messages: [
                {
                    role: "system",
                    content: "Extract optional extra details: label, description, priceInPence (estimate), estimatedHours, materialsCost."
                },
                {
                    role: "user",
                    content: `Extract details for: ${extraDescription}`
                }
            ],
            response_format: { type: "json_object" }
        });

        const result = JSON.parse(response.choices[0].message.content || "{}");
        // Ensure defaults
        const cleanResult = {
            label: result.label || "Extra",
            description: result.description || extraDescription,
            priceInPence: result.priceInPence || 5000,
            estimatedHours: result.estimatedHours || 1,
            materialsCost: result.materialsCost || 0,
            serviceType: 'general',
            complexity: 'moderate'
        };

        res.json(cleanResult);
    } catch (error) {
        console.error("Parse extra error:", error);
        res.status(500).json({ error: "Parsing failed" });
    }
});

// Recalculate Optional Extra Price
quotesRouter.post('/api/recalculate-optional-extra', async (req, res) => {
    try {
        const { serviceType, complexity, estimatedHours, materialsCost } = req.body;

        // Simple calculation logic without AI for speed
        const baseRate = 5000; // £50/hr
        const complexityMultipliers: Record<string, number> = {
            'trivial': 0.8, 'low': 0.9, 'moderate': 1.0, 'medium': 1.0,
            'high': 1.25, 'complex': 1.5, 'very_complex': 2.0
        };

        const multiplier = complexityMultipliers[complexity as string] || 1.0;
        const laborCostInPence = Math.round(estimatedHours * baseRate * multiplier);
        const materialsCostInPence = Math.round((materialsCost || 0) * 100); // input is pounds, store Pence
        const calloutFeeInPence = 0; // Optional Extras usually done while on site

        const priceInPence = laborCostInPence + materialsCostInPence;

        res.json({
            serviceType,
            complexity,
            estimatedHours,
            materialsCost,
            priceInPence,
            materialsCostInPence,
            laborCostInPence,
            calloutFeeInPence
        });

    } catch (error) {
        console.error("Recalculate extra error:", error);
        res.status(500).json({ error: "Recalculation failed" });
    }
});

// Get Quote by Slug
quotesRouter.get('/api/personalized-quotes/:slug', async (req, res) => {
    try {
        const { slug } = req.params;
        const result = await db.select().from(personalizedQuotes).where(eq(personalizedQuotes.shortSlug, slug)).limit(1);
        const quote = result[0];

        if (!quote) {
            return res.status(404).json({ error: "Quote not found" });
        }

        // Track first view - update viewedAt if not already set
        if (!quote.viewedAt) {
            const now = new Date();
            await db.update(personalizedQuotes)
                .set({ viewedAt: now })
                .where(eq(personalizedQuotes.id, quote.id));

            // Return updated quote with viewedAt
            res.json({ ...quote, viewedAt: now });
        } else {
            res.json(quote);
        }

    } catch (error) {
        console.error("Get quote error:", error);
        res.status(500).json({ error: "Failed to fetch quote" });
    }
});

// List all personalized quotes (for admin Generated Quotes tab)
quotesRouter.get('/api/personalized-quotes', async (req, res) => {
    try {
        const allQuotes = await db.select().from(personalizedQuotes)
            .orderBy(desc(personalizedQuotes.createdAt));
        res.json(allQuotes);
    } catch (error) {
        console.error("List quotes error:", error);
        res.status(500).json({ error: "Failed to fetch quotes" });
    }
});

// Track package selection (when customer clicks a tier)
quotesRouter.put('/api/personalized-quotes/:id/track-selection', async (req, res) => {
    try {
        const { id } = req.params;
        const { selectedPackage } = req.body;

        await db.update(personalizedQuotes)
            .set({ selectedPackage, selectedAt: new Date() })
            .where(eq(personalizedQuotes.id, id));

        res.json({ success: true });
    } catch (error) {
        console.error("Track selection error:", error);
        res.status(500).json({ error: "Failed to track selection" });
    }
});

// Track booking (when customer completes payment)
quotesRouter.put('/api/personalized-quotes/:id/track-booking', async (req, res) => {
    try {
        const { id } = req.params;
        const { leadId, selectedPackage, selectedExtras, paymentType } = req.body;

        // Calculate selected tier price
        const [quote] = await db.select().from(personalizedQuotes)
            .where(eq(personalizedQuotes.id, id));

        if (!quote) {
            return res.status(404).json({ error: "Quote not found" });
        }

        let selectedTierPricePence = 0;
        if (selectedPackage === 'essential') {
            selectedTierPricePence = quote.essentialPrice || quote.basePrice || 0;
        } else if (selectedPackage === 'enhanced') {
            selectedTierPricePence = quote.enhancedPrice || 0;
        } else if (selectedPackage === 'elite') {
            selectedTierPricePence = quote.elitePrice || 0;
        } else if (quote.basePrice) {
            selectedTierPricePence = quote.basePrice;
        }

        // Calculate deposit: 100% materials + 30% labor
        const materialsCost = quote.materialsCostWithMarkupPence || 0;
        const laborCost = Math.max(0, selectedTierPricePence - materialsCost);
        const depositAmountPence = materialsCost + Math.round(laborCost * 0.30);

        await db.update(personalizedQuotes)
            .set({
                leadId,
                selectedPackage,
                selectedExtras: selectedExtras || [],
                bookedAt: new Date(),
                paymentType,
                selectedTierPricePence,
                depositAmountPence,
                depositPaidAt: new Date(),
            })
            .where(eq(personalizedQuotes.id, id));

        res.json({ success: true });
    } catch (error) {
        console.error("Track booking error:", error);
        res.status(500).json({ error: "Failed to track booking" });
    }
});

// Get invoice data for a booked quote
quotesRouter.get('/api/personalized-quotes/:id/invoice-data', async (req, res) => {
    try {
        const { id } = req.params;
        const [quote] = await db.select().from(personalizedQuotes)
            .where(eq(personalizedQuotes.id, id));

        if (!quote) {
            return res.status(404).json({ error: "Quote not found" });
        }

        const totalJobPricePence = quote.selectedTierPricePence || 0;
        const depositAmountPence = quote.depositAmountPence || 0;
        const remainingBalancePence = totalJobPricePence - depositAmountPence;

        res.json({
            ...quote,
            totalJobPricePence,
            remainingBalancePence,
        });
    } catch (error) {
        console.error("Invoice data error:", error);
        res.status(500).json({ error: "Failed to fetch invoice data" });
    }
});

// Admin: Manually expire a quote
quotesRouter.post('/api/admin/personalized-quotes/:id/expire', async (req, res) => {
    try {
        const { id } = req.params;

        await db.update(personalizedQuotes)
            .set({ expiresAt: new Date() }) // Set expiry to now = expired
            .where(eq(personalizedQuotes.id, id));

        res.json({ success: true, expired: true });
    } catch (error) {
        console.error("Expire quote error:", error);
        res.status(500).json({ error: "Failed to expire quote" });
    }
});

// Admin: Regenerate an expired quote with price increase and fresh timer
quotesRouter.post('/api/admin/personalized-quotes/:id/regenerate', async (req, res) => {
    try {
        const { id } = req.params;
        const { percentageIncrease = 5 } = req.body;

        // Get original quote
        const [original] = await db.select().from(personalizedQuotes)
            .where(eq(personalizedQuotes.id, id));

        if (!original) {
            return res.status(404).json({ error: "Quote not found" });
        }

        const multiplier = 1 + (percentageIncrease / 100);

        // Update the quote with new prices and fresh 15-minute timer
        await db.update(personalizedQuotes)
            .set({
                essentialPrice: original.essentialPrice ? Math.round(original.essentialPrice * multiplier) : null,
                enhancedPrice: original.enhancedPrice ? Math.round(original.enhancedPrice * multiplier) : null,
                elitePrice: original.elitePrice ? Math.round(original.elitePrice * multiplier) : null,
                basePrice: original.basePrice ? Math.round(original.basePrice * multiplier) : null,
                expiresAt: new Date(Date.now() + 15 * 60 * 1000), // Fresh 15 min timer
                regenerationCount: (original.regenerationCount || 0) + 1,
            })
            .where(eq(personalizedQuotes.id, id));

        res.json({ success: true, regenerated: true });
    } catch (error) {
        console.error("Regenerate quote error:", error);
        res.status(500).json({ error: "Failed to regenerate quote" });
    }
});

// Delete a quote
quotesRouter.delete('/api/personalized-quotes/:id', async (req, res) => {
    try {
        const { id } = req.params;
        console.log(`[DELETE] Attempting to delete quote: ${id}`);

        const result = await db.delete(personalizedQuotes)
            .where(eq(personalizedQuotes.id, id))
            .returning();

        console.log(`[DELETE] Result:`, result);

        if (!result.length) {
            console.log(`[DELETE] Quote not found: ${id}`);
            return res.status(404).json({ error: "Quote not found" });
        }

        console.log(`[DELETE] Successfully deleted quote: ${id}`);
        res.json({ success: true });
    } catch (error) {
        console.error("Delete quote error:", error);
        res.status(500).json({ error: "Failed to delete quote" });
    }
});
