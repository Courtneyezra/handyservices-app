import { Router, Request, Response } from "express";
import { db } from "./db";
import { contractorBookingRequests, handymanProfiles, personalizedQuotes, handymanSkills, productizedServices, contractorJobs, expenses } from "../shared/schema";
import { eq, desc, and, gte, sql } from "drizzle-orm";
import { requireContractorAuth } from "./contractor-auth";
import { AutoSkuGenerator } from "./services";
import { z } from "zod";
import { nanoid } from "nanoid";
import { openai } from "./openai";
import { generateValuePricingQuote, generateTierDeliverables } from "./value-pricing-engine";

const onboardingSchema = z.object({
    services: z.array(z.object({
        trade: z.string(),
        hourlyRatePence: z.number().int().nonnegative(),
        dayRatePence: z.number().int().nonnegative()
    }))
});

const createQuoteSchema = z.object({
    customerName: z.string().min(1),
    customerPhone: z.string().min(1),
    jobDescription: z.string().min(10),
});

const router = Router();

// GET /api/contractor/bookings
// Get all booking requests for the authenticated contractor
router.get('/bookings', requireContractorAuth, async (req: Request, res: Response) => {
    try {
        const contractor = (req as any).contractor;

        // Get contractor profile ID
        const profile = await db.query.handymanProfiles.findFirst({
            where: eq(handymanProfiles.userId, contractor.id),
            columns: { id: true }
        });

        if (!profile) {
            return res.status(404).json({ error: 'Contractor profile not found' });
        }

        const bookings = await db.select()
            .from(contractorBookingRequests)
            .where(eq(contractorBookingRequests.contractorId, profile.id))
            .orderBy(desc(contractorBookingRequests.createdAt));

        res.json(bookings);
    } catch (error) {
        console.error('[ContractorDashboard] Get bookings error:', error);
        res.status(500).json({ error: 'Failed to fetch bookings' });
    }
});

// GET /api/contractor/quotes
// Get all quotes generated by the authenticated contractor
router.get('/quotes', requireContractorAuth, async (req: Request, res: Response) => {
    try {
        const contractor = (req as any).contractor;

        const quotes = await db.select({
            id: personalizedQuotes.id,
            shortSlug: personalizedQuotes.shortSlug,
            customerName: personalizedQuotes.customerName,
            jobDescription: personalizedQuotes.jobDescription,
            quoteMode: personalizedQuotes.quoteMode,
            basePricePence: personalizedQuotes.basePrice, // For simple mode
            baseJobPricePence: personalizedQuotes.baseJobPricePence, // For HHH mode logic
            essentialPrice: personalizedQuotes.essentialPrice, // For HHH mode display
            viewedAt: personalizedQuotes.viewedAt,
            bookedAt: personalizedQuotes.bookedAt,
            expiresAt: personalizedQuotes.expiresAt,
            createdAt: personalizedQuotes.createdAt,
            status: personalizedQuotes.installmentStatus // Using this as a proxy for now if needed, or deduce status on client
        })
            .from(personalizedQuotes)
            .where(eq(personalizedQuotes.contractorId, contractor.id))
            .orderBy(desc(personalizedQuotes.createdAt));

        res.json(quotes);
    } catch (error) {
        console.error('[ContractorDashboard] Get quotes error:', error);
        res.status(500).json({ error: 'Failed to fetch quotes' });
    }
});

// GET /api/contractor/services
// Get all available services (SKUs) for the authenticated contractor
router.get('/services', requireContractorAuth, async (req: Request, res: Response) => {
    try {
        const contractor = (req as any).contractor;

        const profile = await db.query.handymanProfiles.findFirst({
            where: eq(handymanProfiles.userId, contractor.id),
            with: {
                skills: {
                    with: {
                        service: true
                    }
                }
            }
        });

        if (!profile) {
            return res.status(404).json({ error: 'Contractor profile not found' });
        }

        // BACKFILL: If no services, generate defaults
        if (profile.skills.length === 0) {
            console.log('[Dashboard] Backfilling default SKUs for user', contractor.id);
            await AutoSkuGenerator.generateForContractor({
                userId: contractor.id,
                profileId: profile.id,
                services: [{ trade: 'handyman', hourlyRatePence: 5000, dayRatePence: 35000 }]
            });
            // Refetch
            const updatedProfile = await db.query.handymanProfiles.findFirst({
                where: eq(handymanProfiles.userId, contractor.id),
                with: { skills: { with: { service: true } } }
            });
            return res.json(updatedProfile?.skills.map(s => s.service) || []);
        }

        // Flatten logic: skills -> service
        const services = profile.skills.map(s => s.service);
        res.json(services);
    } catch (error) {
        console.error('[ContractorDashboard] Get services error:', error);
        res.status(500).json({ error: 'Failed to fetch services' });
    }
});

// POST /api/contractor/bookings/:id/respond
// Accept or Decline a booking request
router.post('/bookings/:id/respond', requireContractorAuth, async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const { status } = req.body; // 'accepted' | 'declined'
        const contractor = (req as any).contractor;

        if (!['accepted', 'declined'].includes(status)) {
            return res.status(400).json({ error: 'Invalid status' });
        }

        // Verify ownership
        const profile = await db.query.handymanProfiles.findFirst({
            where: eq(handymanProfiles.userId, contractor.id),
            columns: { id: true }
        });

        if (!profile) {
            return res.status(404).json({ error: 'Contractor profile not found' });
        }

        const booking = await db.query.contractorBookingRequests.findFirst({
            where: eq(contractorBookingRequests.id, id)
        });

        if (!booking || booking.contractorId !== profile.id) {
            return res.status(404).json({ error: 'Booking not found' });
        }

        // Update status
        await db.update(contractorBookingRequests)
            .set({
                status: status,
                updatedAt: new Date()
            })
            .where(eq(contractorBookingRequests.id, id));

        // TODO: Send email/SMS notification to customer

        res.json({ success: true, status });
    } catch (error) {
        console.error('[ContractorDashboard] Respond booking error:', error);
        res.status(500).json({ error: 'Failed to update booking' });
    }
});

// Connection test endpoint
router.get('/connection-test', requireContractorAuth, (req: Request, res: Response) => {
    res.json({ status: "ok", message: "Connection successful" });
});

// POST /api/contractor/onboarding/complete

// Finalize onboarding: Generate SKUs from rates
router.post('/onboarding/complete', requireContractorAuth, async (req: Request, res: Response) => {
    try {
        const validation = onboardingSchema.safeParse(req.body);
        if (!validation.success) {
            return res.status(400).json({ error: "Invalid payload", details: validation.error.errors });
        }

        const { services } = validation.data;
        const contractor = (req as any).contractor;

        // 1. Get profile
        const profile = await db.query.handymanProfiles.findFirst({
            where: eq(handymanProfiles.userId, contractor.id),
            columns: { id: true }
        });

        if (!profile) return res.status(404).json({ error: "Profile not found" });

        // 2. Generate SKUs
        // Check if AutoSkuGenerator is working (it should be)
        const skus = await AutoSkuGenerator.generateForContractor({
            userId: contractor.id,
            profileId: profile.id,
            services: services // [{ trade, hourlyRatePence, dayRatePence }]
        });

        res.json({ success: true, skusGenerated: skus.length });

    } catch (error) {
        console.error('[Onboarding] Error:', error);
        if (error instanceof Error) {
            console.error('[Onboarding] Stack:', error.stack);
        }
        res.status(500).json({ error: "Failed to complete onboarding", details: String(error) });
    }
});

// POST /api/contractor/quotes/create
// Generate a new Private Quote using AI and Contractor Rates
router.post('/quotes/create', requireContractorAuth, async (req: Request, res: Response) => {
    try {
        const validation = createQuoteSchema.safeParse(req.body);
        if (!validation.success) {
            return res.status(400).json({ error: "Invalid payload", details: validation.error.errors });
        }

        const { customerName, customerPhone, jobDescription } = validation.data;
        const contractor = (req as any).contractor;

        // 0. CHECK USAGE LIMIT (Freemium Gating)
        const now = new Date();
        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

        const currentMonthQuotes = await db.select({ count: sql<number>`count(*)` })
            .from(personalizedQuotes)
            .where(and(
                eq(personalizedQuotes.contractorId, contractor.id),
                gte(personalizedQuotes.createdAt, startOfMonth)
            ));

        const usageCount = Number(currentMonthQuotes[0]?.count || 0);
        const FREE_LIMIT = 3;

        if (usageCount >= FREE_LIMIT) {
            return res.status(403).json({
                error: "Usage limit exceeded",
                code: "LIMIT_REACHED",
                details: "You have used your 3 free quotes for this month. Upgrade to Premium for unlimited quotes."
            });
        }

        // 1. Analyze Job with AI to get hours and trade
        const analysisResponse = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: [
                {
                    role: "system",
                    content: `Analyze this handyman job. Return JSON:
                    {
                        "estimatedHours": number (minimum 1),
                        "trade": string (one of: 'plumbing', 'electrical', 'painting', 'carpentry', 'mounting', 'general'),
                        "complexity": "low" | "medium" | "high",
                        "summary": string (professional summary),
                        "tasks": [{ "deliverable": string, "complexity": string }]
                    }`
                },
                { role: "user", content: jobDescription }
            ],
            response_format: { type: "json_object" }
        });

        const analysis = JSON.parse(analysisResponse.choices[0].message.content || "{}");
        const estimatedHours = Math.max(1, analysis.estimatedHours || 1);
        const trade = analysis.trade || 'general';

        // 2. Get Contractor's Rate for this trade
        // First get profile ID
        const profile = await db.query.handymanProfiles.findFirst({
            where: eq(handymanProfiles.userId, contractor.id),
            with: { skills: { with: { service: true } } }
        });

        if (!profile) return res.status(404).json({ error: "Profile not found" });

        // Find matching skill/service or default to highest rate
        let hourlyRatePence = 5000; // Default £50 fallback

        const matchingSkill = profile.skills.find(s =>
            s.service.name.toLowerCase().includes(trade) ||
            s.service.category?.toLowerCase().includes(trade)
        );
        if (matchingSkill) {
            if (matchingSkill.hourlyRate) {
                hourlyRatePence = matchingSkill.hourlyRate;
            } else if (matchingSkill.service.pricePence > 0) {
                hourlyRatePence = matchingSkill.service.pricePence;
            }
        } else if (profile.skills.length > 0) {
            // Fallback to their first service rate, checking for override there too
            const firstSkill = profile.skills[0];
            hourlyRatePence = firstSkill.hourlyRate || firstSkill.service.pricePence;
        }

        // 3. Calculate Base Price
        const baseJobPrice = hourlyRatePence * estimatedHours;

        // 4. Generate Value Pricing Multipliers (HHH)
        const pricingResult = generateValuePricingQuote({
            baseJobPrice,
            urgencyReason: 'med', // Default
            ownershipContext: 'homeowner', // Default
            desiredTimeframe: 'week', // Default
            clientType: 'residential',
            jobComplexity: analysis.complexity || 'low',
            forcedQuoteStyle: 'hhh'
        });

        // 5. Generate Deliverables text
        const tierDeliverables = generateTierDeliverables({ tasks: analysis.tasks }, jobDescription);

        // 6. Create Quote Record
        const shortSlug = nanoid(8);
        const id = `quote_${nanoid()}`;

        await db.insert(personalizedQuotes).values({
            id,
            shortSlug,
            contractorId: contractor.id,
            customerName,
            phone: customerPhone,
            jobDescription,
            quoteMode: 'hhh',

            // Prices
            essentialPrice: pricingResult.essential.price,
            enhancedPrice: pricingResult.hassleFree.price,
            elitePrice: pricingResult.highStandard.price,

            // Metadata
            urgencyReason: 'med',
            ownershipContext: 'homeowner',
            desiredTimeframe: 'week',
            baseJobPricePence: baseJobPrice,
            valueMultiplier100: Math.round(pricingResult.valueMultiplier * 100),
            recommendedTier: pricingResult.recommendedTier,
            tierDeliverables: {
                essential: tierDeliverables.essential,
                hassleFree: tierDeliverables.hassleFree,
                highStandard: tierDeliverables.highStandard
            },

            createdAt: new Date(),
            expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days expiry for private quotes
        });

        res.json({ success: true, shortSlug, pricingResult });

    } catch (error) {
        console.error('[QuoteGen] Error:', error);
        res.status(500).json({ error: "Failed to generate quote" });
    }
});

// GET /api/contractor/skills
// Get all skills with their specific rates for the authenticated contractor
router.get('/skills', requireContractorAuth, async (req: Request, res: Response) => {
    try {
        const contractor = (req as any).contractor;

        const profile = await db.query.handymanProfiles.findFirst({
            where: eq(handymanProfiles.userId, contractor.id),
            with: {
                skills: {
                    with: {
                        service: true
                    }
                }
            }
        });

        if (!profile) {
            return res.status(404).json({ error: 'Contractor profile not found' });
        }

        // Transform to cleaner format
        const skills = profile.skills.map(skill => ({
            id: skill.id,
            serviceId: skill.serviceId,
            name: skill.service.name,
            description: skill.service.description,
            hourlyRate: skill.hourlyRate || skill.service.pricePence // Use override or default
        }));

        res.json(skills);
    } catch (error) {
        console.error('[ContractorDashboard] Get skills error:', error);
        res.status(500).json({ error: 'Failed to fetch skills' });
    }
});

// POST /api/contractor/skills
// Update rates for specific skills
router.post('/skills', requireContractorAuth, async (req: Request, res: Response) => {
    try {
        // Schema for bulk update
        const updateSchema = z.object({
            updates: z.array(z.object({
                id: z.string(), // HandymanSkill ID
                hourlyRate: z.number().int().nonnegative() // New rate in pence
            }))
        });

        const validation = updateSchema.safeParse(req.body);
        if (!validation.success) {
            return res.status(400).json({ error: "Invalid payload", details: validation.error.errors });
        }

        const { updates } = validation.data;
        const contractor = (req as any).contractor;

        // Verify ownership for all skills
        const profile = await db.query.handymanProfiles.findFirst({
            where: eq(handymanProfiles.userId, contractor.id),
            with: { skills: true }
        });

        if (!profile) return res.status(404).json({ error: "Profile not found" });

        const ownSkillIds = new Set(profile.skills.map(s => s.id));

        const invalidIds = updates.filter(u => !ownSkillIds.has(u.id));
        if (invalidIds.length > 0) {
            return res.status(403).json({ error: "Unauthorized access to some skills" });
        }

        // Perform updates
        // Since we have multiple updates, we do them in a loop or transaction
        // Drizzle doesn't have a simple bulk update for different values yet, so loop is fine for small numbers
        await db.transaction(async (tx) => {
            for (const update of updates) {
                await tx.update(handymanSkills)
                    .set({ hourlyRate: update.hourlyRate })
                    .where(eq(handymanSkills.id, update.id));
            }
        });

        res.json({ success: true, updatedCount: updates.length });
    } catch (error) {
        console.error('[ContractorDashboard] Update skills error:', error);
        res.status(500).json({ error: 'Failed to update skills' });
    }
});

// PATCH /api/contractor/jobs/:id/status
// Update job status (e.g. pending -> in_progress -> completed)
router.patch('/jobs/:id/status', requireContractorAuth, async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const { status } = req.body;
        const validStatuses = ['pending', 'accepted', 'in_progress', 'completed', 'cancelled'];

        if (!validStatuses.includes(status)) {
            return res.status(400).json({ error: "Invalid status" });
        }

        const contractor = (req as any).contractor;

        // Verify ownership and existence
        const job = await db.query.contractorJobs.findFirst({
            where: and(
                eq(contractorJobs.id, id),
                eq(contractorJobs.contractorId, contractor.profileId || "") // Assuming profileId is available or we join user
            ),
            // Note: contractor object usually has user info. We need to check how contractorJobs links to user vs profile.
            // schema: contractorJobs.contractorId references handymanProfiles.id
        });

        // Wait, 'contractor' in req is likely the User. logic above needs checking.
        // Let's look at previous routes. 
        // In get('/services'), we did:
        /* 
           const profile = await db.query.handymanProfiles.findFirst({
            where: eq(handymanProfiles.userId, contractor.id)
           });
        */

        // So we need to fetch profile first or join.
        // Let's do a reliable ownership check.

        const profile = await db.query.handymanProfiles.findFirst({
            where: eq(handymanProfiles.userId, contractor.id)
        });

        if (!profile) return res.status(404).json({ error: "Profile not found" });

        const targetJob = await db.query.contractorJobs.findFirst({
            where: and(
                eq(contractorJobs.id, id),
                eq(contractorJobs.contractorId, profile.id)
            )
        });

        if (!targetJob) {
            return res.status(404).json({ error: "Job not found" });
        }

        // Prepare updates
        const updates: any = { status, updatedAt: new Date() };

        if (status === 'completed') {
            updates.completedAt = new Date();
        }

        await db.update(contractorJobs)
            .set(updates)
            .where(eq(contractorJobs.id, id));

        res.json({ success: true, status, completedAt: updates.completedAt });
    } catch (error) {
        console.error('[ContractorDashboard] Update job status error:', error);
        res.status(500).json({ error: 'Failed to update job status' });
    }
});

// POST /api/contractor/jobs/:id/payment
// Manually record a payment (e.g. Cash / Bank Transfer)
router.post('/jobs/:id/payment', requireContractorAuth, async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const { amountPence, method } = req.body; // Expecting full amount for now

        const contractor = (req as any).contractor;

        // Verify ownership
        const profile = await db.query.handymanProfiles.findFirst({
            where: eq(handymanProfiles.userId, contractor.id)
        });
        if (!profile) return res.status(404).json({ error: "Profile not found" });

        const job = await db.query.contractorJobs.findFirst({
            where: and(
                eq(contractorJobs.id, id),
                eq(contractorJobs.contractorId, profile.id)
            )
        });

        if (!job) return res.status(404).json({ error: "Job not found" });

        // Update payment status
        await db.update(contractorJobs)
            .set({
                paymentStatus: 'paid',
                paymentMethod: method || 'cash',
                paidAt: new Date(),
                updatedAt: new Date()
            })
            .where(eq(contractorJobs.id, id));

        res.json({ success: true, paymentStatus: 'paid', paidAt: new Date() });
    } catch (error) {
        console.error('[ContractorDashboard] Record payment error:', error);
        res.status(500).json({ error: 'Failed to record payment' });
    }
});

// GET /api/contractor/jobs/:id/invoice
// Generate an invoice for a specific job
router.get('/jobs/:id/invoice', requireContractorAuth, async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const contractor = (req as any).contractor;

        // Verify ownership
        const profile = await db.query.handymanProfiles.findFirst({
            where: eq(handymanProfiles.userId, contractor.id),
            with: { user: true }
        });
        if (!profile) return res.status(404).json({ error: "Profile not found" });

        const job = await db.query.contractorJobs.findFirst({
            where: and(
                eq(contractorJobs.id, id),
                eq(contractorJobs.contractorId, profile.id)
            )
        });

        if (!job) return res.status(404).json({ error: "Job not found" });

        // Generate simple Invoice HTML (mocking a PDF generator)
        // In real app, we'd use 'jspdf' or 'puppeteer'
        const invoiceNumber = `INV-${job.id.substring(0, 8).toUpperCase()}`;
        const date = new Date().toLocaleDateString('en-GB');
        const amount = (job.payoutPence || 0) / 100;

        const html = `
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: sans-serif; padding: 40px; color: #1e293b; }
                .header { display: flex; justify-content: space-between; margin-bottom: 40px; }
                .title { font-size: 32px; font-weight: bold; color: #0f172a; }
                .meta { text-align: right; color: #64748b; }
                .bill-to { margin-bottom: 40px; }
                .table { width: 100%; border-collapse: collapse; margin-bottom: 40px; }
                .table th { text-align: left; padding: 12px; border-bottom: 2px solid #e2e8f0; }
                .table td { padding: 12px; border-bottom: 1px solid #e2e8f0; }
                .total { text-align: right; font-size: 24px; font-weight: bold; }
                .footer { margin-top: 60px; text-align: center; color: #94a3b8; font-size: 12px; }
            </style>
        </head>
        <body>
            <div class="header">
                <div>
                    <div class="title">INVOICE</div>
                    <div>${profile.user?.firstName} ${profile.user?.lastName}</div>
                    <div>${profile.city || ''}</div>
                </div>
                <div class="meta">
                    <div><strong>Invoice #:</strong> ${invoiceNumber}</div>
                    <div><strong>Date:</strong> ${date}</div>
                    <div><strong>Due Date:</strong> ${date}</div>
                </div>
            </div>

            <div class="bill-to">
                <strong>Bill To:</strong><br>
                ${job.customerName || 'Customer'}<br>
                ${job.address || ''}<br>
                ${job.postcode || ''}
            </div>

            <table class="table">
                <thead>
                    <tr>
                        <th>Description</th>
                        <th style="text-align: right">Amount</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>${job.jobDescription || 'Handyman Services'}</td>
                        <td style="text-align: right">£${amount.toFixed(2)}</td>
                    </tr>
                </tbody>
            </table>

            <div class="total">
                Total: £${amount.toFixed(2)}
            </div>
            
            <div class="footer">
                Thank you for your business!
            </div>
        </body>
        </html>
        `;

        // Send content
        res.setHeader('Content-Type', 'text/html');
        res.send(html);

    } catch (error) {
        console.error('[ContractorDashboard] Invoice error:', error);
        res.status(500).json({ error: 'Failed to generate invoice' });
    }
});


// GET /api/contractor/expenses
// Get all expenses for the authenticated contractor
router.get('/expenses', requireContractorAuth, async (req: Request, res: Response) => {
    try {
        const contractor = (req as any).contractor;
        const profile = await db.query.handymanProfiles.findFirst({
            where: eq(handymanProfiles.userId, contractor.id),
            columns: { id: true }
        });

        if (!profile) return res.status(404).json({ error: 'Profile not found' });

        const expensesList = await db.select()
            .from(expenses)
            .where(eq(expenses.contractorId, profile.id))
            .orderBy(desc(expenses.date));

        res.json(expensesList);
    } catch (error) {
        console.error('[Expenses] Get error:', error);
        res.status(500).json({ error: 'Failed to fetch expenses' });
    }
});

// POST /api/contractor/expenses
// Create a new expense
router.post('/expenses', requireContractorAuth, async (req: Request, res: Response) => {
    try {
        const contractor = (req as any).contractor;
        const { description, category, amountPence, date, receiptUrl } = req.body;

        const profile = await db.query.handymanProfiles.findFirst({
            where: eq(handymanProfiles.userId, contractor.id),
            columns: { id: true }
        });

        if (!profile) return res.status(404).json({ error: 'Profile not found' });

        const id = `exp_${nanoid()}`;
        await db.insert(expenses).values({
            id,
            contractorId: profile.id,
            description,
            category,
            amountPence,
            date: new Date(date),
            receiptUrl,
        });

        res.json({ success: true, id });
    } catch (error) {
        console.error('[Expenses] Create error:', error);
        res.status(500).json({ error: 'Failed to create expense' });
    }
});

// GET /api/contractor/stats/financials
// Get monthly financial stats (Income vs Expenses)
router.get('/stats/financials', requireContractorAuth, async (req: Request, res: Response) => {
    try {
        const contractor = (req as any).contractor;
        const profile = await db.query.handymanProfiles.findFirst({
            where: eq(handymanProfiles.userId, contractor.id),
            columns: { id: true }
        });

        if (!profile) return res.status(404).json({ error: 'Profile not found' });

        // Get expenses
        const expenseRecords = await db.select({
            amountPence: expenses.amountPence,
            date: expenses.date
        })
            .from(expenses)
            .where(eq(expenses.contractorId, profile.id));

        // Get income (completed jobs)
        // TODO: This should strictly be 'paid' jobs, but for now using completed jobs with payout
        const jobRecords = await db.select({
            amountPence: contractorJobs.payoutPence,
            date: contractorJobs.completedAt
        })
            .from(contractorJobs)
            .where(and(
                eq(contractorJobs.contractorId, profile.id),
                eq(contractorJobs.status, 'completed'),
                // optionally check paymentStatus = 'paid'
            ));

        // Aggregate by month (last 6 months)
        // Simplified aggregation here or return raw data for frontend
        res.json({ expenses: expenseRecords, jobs: jobRecords });

    } catch (error) {
        console.error('[Financials] Stats error:', error);
        res.status(500).json({ error: 'Failed to fetch financial stats' });
    }
});

export default router;
