
console.log('[Index] Root loading...');
import 'dotenv/config';
import express from "express";
import { createServer } from "http";
import { WebSocketServer } from "ws";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { execSync } from "child_process";
import { db } from "./db";
import { productizedServices, skuMatchLogs, leads } from "../shared/schema";
import { desc, eq } from "drizzle-orm";
import { v4 as uuidv4 } from "uuid";
import { twilioClient } from "./twilio-client";
import { detectSku, detectMultipleTasks, loadAndCacheSkus } from "./skuDetector";
import { setupTwilioSocket } from "./twilio-realtime";
import { initiateOutboundCall } from "./conference-bridge";
import { determineCallRouting, getElevenLabsContextMessage, CallRoutingSettings, AgentMode, FallbackAction } from "./call-routing-engine";

const DEBUG_FILE = path.join(process.cwd(), "server-debug.log");

// Track mapping of Parent CallSid -> Outbound CallSid
const activeBridges = new Map<string, string>();
// Track calls being redirected to Eleven Labs (to prevent conference cleanup interference)
const activeRedirects = new Set<string>();
// Track ParentCallSid -> ConferenceSid for using Participants API
const activeConferences = new Map<string, string>();

function debugLog(message: string, obj?: any) {
    const timestamp = new Date().toISOString();
    let fullMsg = `[${timestamp}] ${message}`;
    if (obj) fullMsg += ` | ${JSON.stringify(obj)}`;
    fs.appendFileSync(DEBUG_FILE, `${fullMsg}\n`);
}

import { quotesRouter } from "./quotes";
import { leadsRouter } from "./leads";
import { testRouter } from "./test-routes";
import { dashboardRouter } from "./dashboard";
import { whatsappRouter } from "./whatsapp-api";
import { metaWhatsAppRouter, attachMetaWebSocket } from "./meta-whatsapp";
import { trainingRouter } from './training-routes';
import handymenRouter from './handymen';
import callsRouter from './calls';
import { generateWhatsAppMessage } from './openai';
import { searchAddresses, validatePostcode } from './google-places'; // B8: Address lookup
import { devRouter } from './dev-tools';
import { settingsRouter, getTwilioSettings } from './settings';
import contractorAuthRouter from './contractor-auth';
import contractorAvailabilityRouter from './availability-routes';
import contractorJobsRouter from './job-routes';
import placesRouter from './places-routes';
import { stripeRouter } from './stripe-routes';


const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
app.use(express.json({ limit: '10mb' })); // Increased limit for large transcriptions
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// API Routers - Absolute priority to avoid SPA catch-all
app.use('/api/settings', settingsRouter);
app.use('/api', leadsRouter);
app.use(quotesRouter);

// Serve static files from attached_assets directory if needed
// app.use('/attached_assets', express.static('attached_assets'));

// Serve WhatsApp Media
const MEDIA_DIR = path.join(__dirname, 'storage/media');
if (!fs.existsSync(MEDIA_DIR)) {
    fs.mkdirSync(MEDIA_DIR, { recursive: true });
}
app.use('/api/media', express.static(MEDIA_DIR));


// Logging Middleware
app.use((req, res, next) => {
    const start = Date.now();
    const path = req.path;
    let capturedJsonResponse: Record<string, any> | undefined = undefined;

    const originalResJson = res.json;
    res.json = function (bodyJson, ...args) {
        capturedJsonResponse = bodyJson;
        return originalResJson.apply(res, [bodyJson, ...args]);
    };

    res.on("finish", () => {
        const duration = Date.now() - start;
        if (path.startsWith("/api")) {
            let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
            if (capturedJsonResponse) {
                logLine += ` :: ${JSON.stringify(capturedJsonResponse).slice(0, 50)}...`;
            }
            console.log(logLine);
        }
    });

    next();
});

// Health Check Endpoint (for Railway and keep-alive pings)
app.get('/api/health', (req, res) => {
    res.status(200).json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        uptime: process.uptime()
    });
});

// Diagnostics Endpoint (Inlined for reliability)
import { getActiveCallCount } from './twilio-realtime';
import { sql } from 'drizzle-orm';
import { getNgrokUrl } from './dev-tools';

app.get('/api/diagnostics', async (req, res) => {
    console.log('[Diagnostics] Endpoint hit');
    const checks = {
        timestamp: new Date().toISOString(),
        env: {
            deepgram_key_set: !!process.env.DEEPGRAM_API_KEY,
            openai_key_set: !!process.env.OPENAI_API_KEY,
            twilio_account_sid_set: !!process.env.TWILIO_ACCOUNT_SID,
            twilio_auth_token_set: !!process.env.TWILIO_AUTH_TOKEN,
            node_env: process.env.NODE_ENV
        },
        infrastructure: {
            database: false,
            host: req.headers.host,
            protocol: req.headers['x-forwarded-proto'] || req.protocol,
            server_uptime: process.uptime(),
            active_tunnel: await getNgrokUrl('http://127.0.0.1:4040/api/tunnels')
        },
        voice_server: {
            active_calls: getActiveCallCount(),
        }
    };
    try {
        await db.execute(sql`SELECT 1`);
        checks.infrastructure.database = true;
    } catch (e) {
        console.error("Diagnostics: DB Check Failed", e);
        checks.infrastructure.database = false;
    }

    res.json(checks);
});

app.use(express.static(path.join(__dirname, '../client/dist')));
app.use('/api/places', placesRouter); // API: Places Search
app.use('/api', testRouter);
app.use('/api/whatsapp', whatsappRouter); // Legacy Twilio Webhooks
app.use('/api/whatsapp', metaWhatsAppRouter); // Meta Cloud API Webhooks
app.use('/api/dashboard', dashboardRouter);
app.use('/api/handymen', handymenRouter);
app.use('/api/calls', callsRouter);
app.use('/api/calls', callsRouter);
app.use(trainingRouter);
app.use('/api', devRouter);
// settingsRouter already registered above
app.use(stripeRouter); // Stripe payment routes

// Contractor Portal Routes
app.use('/api/contractor', contractorAuthRouter);
app.use('/api/contractor/availability', contractorAvailabilityRouter);
app.use('/api/contractor/jobs', contractorJobsRouter);
// app.use('/api/places', placesRouter); // API: Places Search (Moved to register before catch-all)

// Serve static assets (for hold music)
app.use('/assets', express.static(path.join(__dirname, '../public/assets')));




// Audio Upload Endpoint (Deepgram)
// import { deepgram } from "./deepgram";

app.post('/api/deepgram/upload', async (req, res) => {
    try {
        if (!req.headers['content-type']?.includes('audio')) {
            return res.status(400).json({ error: "Invalid content type" });
        }

        // Stream the audio directly to Deepgram? 
        // For simplicity in this demo, accessing raw body might require body-parser config or similar.
        // Assuming express.raw or similar is needed if we want the buffer.
        // But here we might just rely on a simple buffer collection for now if small.

        const chunks: Buffer[] = [];
        req.on('data', (chunk) => chunks.push(chunk));
        req.on('end', async () => {
            const buffer = Buffer.concat(chunks);
            // Process with Deepgram (omitted actual call for brevity unless needed)
            // Mock response for now or actual call if deepgram module is ready
            try {
                // const transcription = await deepgram.transcription.preRecorded({ buffer, mimetype: req.headers['content-type'] });
                // res.json({ transcription });
                res.json({ transcription: "Audio processing placeholder" });
            } catch (err) {
                console.error("Deepgram error:", err);
                res.status(500).json({ error: "Failed to process audio" });
            }
        });

        req.on('error', (err) => {
            console.error("Upload stream error:", err);
            res.status(500).json({ error: "Upload failed" });
        });

    } catch (error) {
        console.error("Upload error:", error);
        res.status(500).json({ error: "Internal server error" });
    }
});

// SKU Detection Endpoint
app.post('/api/sku/detect', async (req, res) => {
    const { text } = req.body;
    if (!text) return res.status(400).json({ error: "Missing text" });

    const result = await detectSku(text);
    res.json(result);
});

// Multi-Task Detection
app.post('/api/intake/sku-detect-multi', async (req, res) => {
    const { text } = req.body;
    if (!text) return res.status(400).json({ error: "Missing text" });

    try {
        const result = await detectMultipleTasks(text);
        res.json(result);
    } catch (e) {
        console.error("Multi-task detect error:", e);
        res.status(500).json({ error: "Detection failed" });
    }
});

// AI-Generated WhatsApp Message
app.post('/api/whatsapp/ai-message', async (req, res) => {
    const { transcription, customerName, tone, detection } = req.body;
    try {
        const message = await generateWhatsAppMessage(transcription, customerName, tone || 'casual', detection);
        res.json({ message });
    } catch (e) {
        console.error("AI message error:", e);
        res.status(500).json({ error: "Failed to generate message" });
    }
});

// B8: Address Lookup by Postcode
app.post('/api/addresses/lookup', async (req, res) => {
    const { postcode } = req.body;

    if (!postcode) {
        return res.status(400).json({ error: "Postcode is required" });
    }

    try {
        // Validate postcode first (free API call)
        const validation = await validatePostcode(postcode);

        if (!validation.valid) {
            return res.json({
                addresses: [],
                cached: false,
                error: "Invalid postcode"
            });
        }

        // Get addresses from Google Places (with caching)
        const addresses = await searchAddresses(postcode);

        res.json({
            addresses,
            cached: addresses.length > 0, // If we got results, they might be cached
            postcode: validation.postcode // Return normalized postcode
        });
    } catch (e) {
        console.error("Address lookup error:", e);
        res.status(500).json({ error: "Failed to lookup addresses" });
    }
});

// SKU / Services Management API
// ------------------------------------------------------------------

// 1. List all SKUs
app.get('/api/skus', async (req, res) => {
    try {
        const skus = await db.select().from(productizedServices).orderBy(desc(productizedServices.skuCode));
        res.json(skus);
    } catch (error) {
        console.error("Failed to fetch SKUs:", error);
        res.status(500).json({ error: "Failed to fetch SKUs" });
    }
});

// 2. Create SKU
app.post('/api/skus', async (req, res) => {
    try {
        const newSku = {
            id: uuidv4(),
            ...req.body,
            // Ensure strict defaults if missing
            isActive: req.body.isActive ?? true,
            keywords: req.body.keywords || [],
        };

        await db.insert(productizedServices).values(newSku);
        res.json(newSku);
    } catch (error) {
        console.error("Failed to create SKU:", error);
        res.status(500).json({ error: "Failed to create SKU" });
    }
});

// 3. Update SKU
app.put('/api/skus/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const updates = req.body;

        // Remove ID from updates to avoid PK conflict if passed
        delete updates.id;

        await db.update(productizedServices)
            .set(updates)
            .where(eq(productizedServices.id, id));

        res.json({ success: true, id });
    } catch (error) {
        console.error("Failed to update SKU:", error);
        res.status(500).json({ error: "Failed to update SKU" });
    }
});

// 4. Delete SKU
app.delete('/api/skus/:id', async (req, res) => {
    try {
        const { id } = req.params;
        await db.delete(productizedServices).where(eq(productizedServices.id, id));
        res.json({ success: true });
    } catch (error) {
        console.error("Failed to delete SKU:", error);
        res.status(500).json({ error: "Failed to delete SKU" });
    }
});

// Mock Endpoints
app.post('/api/intake/pre-analyze', (req, res) => {
    res.json({ visualReason: "To assess access", needsVisual: true });
});

app.post('/api/intake/decision', (req, res) => {
    res.json({
        intakeId: `intake_${Date.now()}`,
        recommendation: 'VIDEO_QUOTE',
        rationale: "We need to see the job to give an accurate price.",
        confidence: 80,
        primaryAction: {
            label: "Get Video Quote",
            description: "Send a quick video for a fixed price",
            route: "/video-quote"
        },
        alternatives: [],
        freeVideoOption: {
            label: "Quick Video",
            description: "Free assessment",
            visualReason: "Complex job",
            route: "/video-instant"
        }
    });
});

// Twilio Voice Webhook - Dynamic settings-based call routing using routing engine
app.post('/api/twilio/voice', async (req, res) => {
    debugLog(`[Voice] Incoming from ${req.body.From}`, {
        sid: req.body.CallSid
    });
    console.log(`[Twilio] Incoming call from ${req.body.From}`);
    const host = req.headers.host || 'localhost:5001';
    const wsProtocol = req.headers['x-forwarded-proto'] === 'https' ? 'wss' : 'ws';
    const httpProtocol = req.headers['x-forwarded-proto'] === 'https' ? 'https' : 'http';
    const streamUrl = `${wsProtocol}://${host}/api/twilio/realtime`;

    // Log call immediately as "ringing" to capture drop-offs
    try {
        await createCall({
            callId: req.body.CallSid,
            phoneNumber: req.body.From,
            direction: "inbound",
            status: "ringing",
            customerName: "Unknown Caller",
        });
    } catch (e) {
        console.error(`[Twilio] Failed to log initial call ${req.body.CallSid}:`, e);
    }

    // Get dynamic settings
    const settings = await getTwilioSettings();

    // Build routing settings for the engine
    const routingSettings: CallRoutingSettings = {
        agentMode: (settings.agentMode || 'auto') as AgentMode,
        forwardEnabled: settings.forwardEnabled,
        forwardNumber: settings.forwardNumber,
        fallbackAction: (settings.fallbackAction || 'voicemail') as FallbackAction,
        businessHoursStart: settings.businessHoursStart,
        businessHoursEnd: settings.businessHoursEnd,
        businessDays: settings.businessDays,
        elevenLabsAgentId: settings.elevenLabsAgentId,
        elevenLabsApiKey: settings.elevenLabsApiKey,
    };

    // Determine call routing
    const routing = determineCallRouting(routingSettings);
    console.log(`[Twilio] Routing decision: ${routing.reason} (mode: ${routing.effectiveMode}, destination: ${routing.destination})`);

    const welcomeMessage = (settings.welcomeMessage as string).replace('{business_name}', settings.businessName as string);
    const holdMusicUrl = `${httpProtocol}://${host}/api/twilio/hold-music`;
    const leadNumber = req.body.From;
    const twilioUKNumber = req.body.To || settings.twilioPhoneNumber || process.env.TWILIO_PHONE_NUMBER;

    // Start TwiML response
    let twiml = `<?xml version="1.0" encoding="UTF-8"?>
    <Response>
      <Start>
        <Stream url="${streamUrl}">
            <Parameter name="phoneNumber" value="${req.body.From}" />
        </Stream>
      </Start>`;

    // Add welcome audio ONLY if routing dictates
    if (routing.playWelcomeAudio) {
        if (settings.welcomeAudioUrl) {
            let audioUrl = settings.welcomeAudioUrl as string;
            if (audioUrl.startsWith('/')) {
                audioUrl = `${httpProtocol}://${host}${audioUrl}`;
            }
            twiml += `<Play>${audioUrl}</Play>`;
        } else {
            twiml += `<Say voice="${settings.voice}">${welcomeMessage}</Say>`;
        }
    }

    // Route based on decision
    if (routing.destination === 'voicemail') {
        // Direct to voicemail
        twiml += `
        <Redirect>${httpProtocol}://${host}/api/twilio/voicemail</Redirect>`;
    } else if (routing.destination === 'eleven-labs') {
        // Direct to Eleven Labs (for OOH or no-forward in-hours)
        const elevenLabsUrl = `${httpProtocol}://${host}/api/twilio/eleven-labs-personal?agentId=${settings.elevenLabsAgentId}&leadPhoneNumber=${encodeURIComponent(leadNumber)}&context=${routing.elevenLabsContext}`;
        twiml += `
        <Redirect>${elevenLabsUrl}</Redirect>`;
    } else if (routing.destination === 'va-forward' && routing.attemptVAForward) {
        // Try VA forwarding with conference bridge
        const conferenceName = `Call_${req.body.CallSid}`;

        // Send SMS to agent ONLY if in-hours (routing.sendVASms)
        if (routing.sendVASms) {
            const agentNotifyBody = settings.agentNotifySms
                .replace('{lead_number}', leadNumber)
                .replace('{twilio_uk_number}', twilioUKNumber);

            twilioClient.messages.create({
                body: agentNotifyBody,
                from: twilioUKNumber,
                to: settings.forwardNumber
            }).catch(err => console.error(`[Twilio] Failed to send agent notification SMS:`, err));
        }

        // Initiate outbound call to agent
        initiateOutboundCall(req.body.CallSid, settings.forwardNumber, conferenceName, host, httpProtocol, leadNumber)
            .then(outboundSid => {
                if (outboundSid) {
                    activeBridges.set(req.body.CallSid, outboundSid);
                    debugLog(`[Bridge] Linked ${req.body.CallSid} -> ${outboundSid}`);
                }
            })
            .catch(err => console.error(`[Twilio] Failed to initiate outbound bridge:`, err));

        // Place caller in conference
        // IMPORTANT: action URL is where Twilio goes AFTER the dial ends (timeout, no-answer, etc.)
        twiml += `
        <Dial action="${httpProtocol}://${host}/api/twilio/dial-complete?leadNumber=${encodeURIComponent(leadNumber)}" timeout="${settings.maxWaitSeconds || 30}">
            <Conference 
                startConferenceOnEnter="false" 
                endConferenceOnExit="false" 
                waitUrl="${holdMusicUrl}" 
                beep="false"
                statusCallbackEvent="start end join leave mute hold" 
                statusCallback="${httpProtocol}://${host}/api/twilio/conference-status">
                ${conferenceName}
            </Conference>
        </Dial>`;
    } else {
        // Fallback: hangup or transcription mode
        twiml += `
      <Pause length="30" />
      <Say voice="${settings.voice}">I'm still listening. Go ahead whenever you're ready.</Say>
      <Pause length="30" />
      <Say voice="${settings.voice}">Thank you for the details. We are analyzing your request and will be with you shortly.</Say>
      <Pause length="10" />`;
    }

    twiml += `
    </Response>`;

    res.type('text/xml');
    res.send(twiml);
});

// Local Hold Music Endpoint - Returns TwiML to play classical music
app.all('/api/twilio/hold-music', (req, res) => {
    debugLog(`[Hold-Music] Request hit`);
    const twiml = `<?xml version="1.0" encoding="UTF-8"?>
    <Response>
        <Play loop="0">https://demo.twilio.com/docs/classic.mp3</Play>
    </Response>`;
    res.type('text/xml');
    res.send(twiml);
});

// Agent Join Endpoint - Places the agent into the *same* conference with a whisper
app.post('/api/twilio/agent-join', async (req, res) => {
    const conferenceName = req.query.conference as string || req.body.conference;
    const leadNumber = req.query.leadNumber as string || req.body.leadNumber;

    debugLog(`[Agent-Join] Request hit | ${conferenceName}`, { leadNumber });
    console.log(`[Twilio-Bridge] Agent answering, joining ${conferenceName}`);

    const settings = await getTwilioSettings();

    // Agent joins immediately (startConferenceOnEnter=true)
    // We add a whisper before bridging
    let twiml = `<?xml version="1.0" encoding="UTF-8"?>
    <Response>`;

    if (settings.whisperEnabled && leadNumber) {
        // Read digits clearly for the whisper, skipping the '+'
        const digits = leadNumber.replace(/\D/g, '').split('').join(' ');
        twiml += `<Say voice="${settings.voice}">Incoming call from ${digits}</Say>`;
    }

    twiml += `
        <Dial>
            <Conference 
                startConferenceOnEnter="true" 
                endConferenceOnExit="true" 
                beep="false">
                ${conferenceName}
            </Conference>
        </Dial>
    </Response>`;

    res.type('text/xml');
    res.send(twiml);
});

// Voicemail Endpoint
app.post('/api/twilio/voicemail', async (req, res) => {
    const settings = await getTwilioSettings();
    const host = req.headers.host || 'localhost:5001';
    const httpProtocol = req.headers['x-forwarded-proto'] === 'https' ? 'https' : 'http';

    const twiml = `<?xml version="1.0" encoding="UTF-8"?>
    <Response>
        <Say voice="${settings.voice}">Sorry we missed you. Please leave a short message and we'll WhatsApp you back ASAP.</Say>
        <Record 
            maxLength="60" 
            trimSilence="true" 
            playBeep="true"
            action="${httpProtocol}://${host}/api/twilio/voicemail-finished"
        />
        <Say voice="${settings.voice}">Thank you. Goodbye.</Say>
    </Response>`;

    res.type('text/xml');
    res.send(twiml);
});

// Voicemail Finished Webhook
app.post('/api/twilio/voicemail-finished', async (req, res) => {
    const { CallSid, From, RecordingUrl } = req.body;
    const settings = await getTwilioSettings();
    const twilioUKNumber = settings.twilioPhoneNumber || process.env.TWILIO_PHONE_NUMBER;

    console.log(`[Voicemail] Recorded for ${From}: ${RecordingUrl}`);

    // Update database record
    try {
        const callRecordId = await findCallByTwilioSid(CallSid);
        if (callRecordId) {
            await updateCall(callRecordId, {
                recordingUrl: RecordingUrl,
                outcome: 'VOICEMAIL',
                status: 'completed'
            });
        }
    } catch (e) {
        console.error(`[Voicemail] Failed to update call record:`, e);
    }

    // Notify agent about voicemail
    if (settings.forwardNumber) {
        const agentMissedBody = settings.agentMissedSms
            .replace('{lead_number}', From) + ` Voicemail: ${RecordingUrl}`;

        twilioClient.messages.create({
            body: agentMissedBody,
            from: twilioUKNumber,
            to: settings.forwardNumber
        }).catch(err => console.error(`[Twilio] Failed to send agent missed call SMS:`, err));
    }

    res.sendStatus(200);
});

// Outbound Call Status - Handle busy/no-answer from agent (VA missed call)
app.post('/api/twilio/outbound-status', async (req, res) => {
    const { CallStatus, CallSid, From, To } = req.body;
    // ParentCallSid is passed via query string from conference-bridge.ts
    const ParentCallSid = req.query.parentCallSid as string;
    debugLog(`[Outbound-Status] ${CallStatus}`, { sid: CallSid, parent: ParentCallSid });
    console.log(`[Twilio-Bridge] Agent call ${CallSid} status: ${CallStatus}, ParentCallSid: ${ParentCallSid || 'MISSING'}`);

    const settings = await getTwilioSettings();
    const host = req.headers.host || 'localhost:5001';
    const httpProtocol = req.headers['x-forwarded-proto'] === 'https' ? 'https' : 'http';

    if (['busy', 'failed', 'no-answer', 'canceled'].includes(CallStatus) && ParentCallSid) {
        console.log(`[Twilio-Bridge] Agent missed call. Using routing engine for fallback...`);

        try {
            // Fetch actual lead number from parent call
            const parentCall = await twilioClient.calls(ParentCallSid).fetch();
            const actualLeadNumber = parentCall.from;

            // Use routing engine to determine fallback (isVAMissedCall = true)
            const routingSettings: CallRoutingSettings = {
                agentMode: (settings.agentMode || 'auto') as AgentMode,
                forwardEnabled: settings.forwardEnabled,
                forwardNumber: settings.forwardNumber,
                fallbackAction: (settings.fallbackAction || 'voicemail') as FallbackAction,
                businessHoursStart: settings.businessHoursStart,
                businessHoursEnd: settings.businessHoursEnd,
                businessDays: settings.businessDays,
                elevenLabsAgentId: settings.elevenLabsAgentId,
                elevenLabsApiKey: settings.elevenLabsApiKey,
            };

            const routing = determineCallRouting(routingSettings, true); // isVAMissedCall = true
            console.log(`[Twilio-Bridge] Missed call routing decision: ${routing.reason}`);

            // Mark this call as VA-missed so dial-complete handler knows to redirect
            // The actual redirect will happen via the Dial action URL (dial-complete endpoint)
            activeRedirects.add(ParentCallSid);
            console.log(`[Twilio-Bridge] Marked ${ParentCallSid} for redirect - dial-complete will handle`);

            // Remove from redirect set after a delay
            setTimeout(() => activeRedirects.delete(ParentCallSid), 30000);

        } catch (e) {
            console.error(`[Twilio-Bridge] Failed to handle agent missed call:`, e);
        }
    }

    res.sendStatus(200);
});

// Personalized Eleven Labs Redirection - Uses routing engine for context
app.all('/api/twilio/eleven-labs-personal', async (req, res) => {
    try {
        const agentId = req.query.agentId as string;
        const leadPhoneNumber = req.query.leadPhoneNumber as string;
        const contextParam = req.query.context as string; // 'in-hours', 'out-of-hours', or 'missed-call'
        const settings = await getTwilioSettings();

        debugLog(`[ElevenLabs-Personal] Redirection for ${leadPhoneNumber} to agent ${agentId}, context=${contextParam || 'auto'}`);

        if (!settings.elevenLabsApiKey || !agentId) {
            // Fallback to generic if something is missing
            const twiml = `<?xml version="1.0" encoding="UTF-8"?><Response><Redirect>https://api.elevenlabs.io/v1/convai/conversation/view/${agentId}/twiml-redirect</Redirect></Response>`;
            return res.type('text/xml').send(twiml);
        }

        // Determine context: use param if provided, otherwise calculate from routing engine
        let effectiveContext: 'in-hours' | 'out-of-hours' | 'missed-call' = 'in-hours';

        if (contextParam && ['in-hours', 'out-of-hours', 'missed-call'].includes(contextParam)) {
            effectiveContext = contextParam as 'in-hours' | 'out-of-hours' | 'missed-call';
        } else {
            // Fallback: use routing engine to determine context (for legacy calls without param)
            const routingSettings: CallRoutingSettings = {
                agentMode: (settings.agentMode || 'auto') as AgentMode,
                forwardEnabled: settings.forwardEnabled,
                forwardNumber: settings.forwardNumber,
                fallbackAction: (settings.fallbackAction || 'voicemail') as FallbackAction,
                businessHoursStart: settings.businessHoursStart,
                businessHoursEnd: settings.businessHoursEnd,
                businessDays: settings.businessDays,
                elevenLabsAgentId: settings.elevenLabsAgentId,
                elevenLabsApiKey: settings.elevenLabsApiKey,
            };
            const routing = determineCallRouting(routingSettings);
            effectiveContext = routing.elevenLabsContext || 'in-hours';
        }

        // Get context message using the routing engine helper
        const contextMessage = getElevenLabsContextMessage(effectiveContext, {
            agentContextDefault: settings.agentContextDefault,
            agentContextOutOfHours: settings.agentContextOutOfHours,
            agentContextMissed: settings.agentContextMissed,
        });

        // Build personalized first message
        let firstMessage = "Hello! Thanks for calling Handy Services. How can I help you today?";

        // Lookup customer name in DB for personalization (wrapped in try-catch to not block Eleven Labs)
        try {
            const [lead] = await db.select({
                phone: leads.phone,
                customerName: leads.customerName,
            }).from(leads).where(eq(leads.phone, leadPhoneNumber)).orderBy(desc(leads.createdAt)).limit(1);

            if (lead && lead.customerName) {
                firstMessage = `Hi ${lead.customerName}! Thanks for calling Handy Services. How can I help you today?`;
                console.log(`[ElevenLabs-Personal] Personalizing for ${lead.customerName}`);
            }
        } catch (dbError) {
            console.error(`[ElevenLabs-Personal] DB lookup failed (non-fatal):`, dbError);
            // Continue with default first message
        }

        // Generate Signed URL / Token (GET request per Eleven Labs API docs)
        const signedUrlResponse = await fetch(`https://api.elevenlabs.io/v1/convai/conversation/get_signed_url?agent_id=${agentId}`, {
            method: 'GET',
            headers: {
                'xi-api-key': settings.elevenLabsApiKey,
            }
        });

        if (signedUrlResponse.ok) {
            const { signed_url } = await signedUrlResponse.json();
            const url = new URL(signed_url);
            const token = url.searchParams.get('token');

            console.log(`[ElevenLabs-Personal] Context: ${effectiveContext}, Token obtained successfully`);

            // Note: Need to include Pause after Connect to keep call alive
            const twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Connect>
        <Stream url="wss://api.elevenlabs.io/v1/convai/conversation?agent_id=${agentId}&amp;token=${token}" />
    </Connect>
    <Pause length="600"/>
</Response>`;
            return res.type('text/xml').send(twiml);
        } else {
            // Fallback to voicemail on API failure - don't redirect to unknown agent
            const errorBody = await signedUrlResponse.text();
            console.error(`[ElevenLabs-Personal] Failed to get signed URL: ${signedUrlResponse.status} ${signedUrlResponse.statusText}`, errorBody);

            const twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Say voice="Polly.Amy-Neural">Sorry, we're experiencing technical difficulties. Please leave a message after the tone and we'll call you back.</Say>
    <Record maxLength="120" action="/api/twilio/voicemail" />
</Response>`;
            return res.type('text/xml').send(twiml);
        }
    } catch (error) {
        console.error('[ElevenLabs-Personal] Error:', error);
        res.type('text/xml').send(`<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Say voice="Polly.Amy-Neural">Sorry, we're experiencing technical difficulties. Please leave a message after the tone.</Say>
    <Record maxLength="120" action="/api/twilio/voicemail" />
</Response>`);
    }
});

// Simple Hangup Endpoint - Ends call with a brief message
app.all('/api/twilio/hangup', (req, res) => {
    debugLog(`[Hangup] Ending call`);
    const twiml = `<?xml version="1.0" encoding="UTF-8"?>
    <Response>
        <Say voice="Polly.Amy-Neural">Thank you for calling. We'll be in touch shortly. Goodbye.</Say>
        <Hangup/>
    </Response>`;
    res.type('text/xml');
    res.send(twiml);
});

// Conference Status Callback - Logging
app.post('/api/twilio/conference-status', async (req, res) => {
    const { ConferenceSid, StatusCallbackEvent, FriendlyName, CallSid } = req.body;
    debugLog(`[Conf-Status] ${StatusCallbackEvent} for ${FriendlyName} (${ConferenceSid})`);

    // Track ConferenceSid for participant-join so we can use Participants API later
    if (StatusCallbackEvent === 'participant-join') {
        const parentCallSid = FriendlyName.replace('Call_', '');
        activeConferences.set(parentCallSid, ConferenceSid);
        console.log(`[Conf-Status] Tracked conference for ${parentCallSid} -> ${ConferenceSid}`);
    }

    // If conference ends or caller leaves, kill the outbound leg
    // BUT skip if call is being redirected to Eleven Labs
    if (['conference-end', 'participant-leave'].includes(StatusCallbackEvent)) {
        const parentCallSid = FriendlyName.replace('Call_', '');

        // Skip cleanup if this call is being redirected to Eleven Labs
        if (activeRedirects.has(parentCallSid)) {
            debugLog(`[Bridge] Skipping cleanup - call ${parentCallSid} is being redirected`);
            return res.sendStatus(200);
        }

        const outboundSid = activeBridges.get(parentCallSid);

        if (outboundSid) {
            debugLog(`[Bridge] Parent ended. Killing outbound leg ${outboundSid}`);
            try {
                await twilioClient.calls(outboundSid).update({ status: 'completed' });
                activeBridges.delete(parentCallSid);
            } catch (e) {
                console.error(`[Bridge] Failed to kill outbound leg:`, e);
            }
        }
    }
    res.sendStatus(200);
});

// Dial Complete Handler - Called when the conference dial times out or ends
// This is the NEW way to handle VA no-answer - returns TwiML directly instead of API call
app.post('/api/twilio/dial-complete', async (req, res) => {
    const { DialCallStatus, CallSid, DialCallDuration } = req.body;
    const leadNumber = req.query.leadNumber as string || req.body.From;

    console.log(`[Dial-Complete] Call ${CallSid} - DialCallStatus: ${DialCallStatus}, Lead: ${leadNumber}`);

    // Check if this call was marked as VA-missed by outbound-status handler
    // (activeRedirects set is set when VA doesn't answer)
    // RACE CONDITION FIX: Use DialCallDuration instead - if < 3s, VA didn't really answer
    const dialDuration = parseInt(DialCallDuration) || 0;
    const vaMissedCall = dialDuration < 3;
    console.log(`[Dial-Complete] Duration: ${dialDuration}s, VA Missed: ${vaMissedCall}`);

    // If VA didn't miss the call (they actually answered and talked), just end
    if (!vaMissedCall) {
        console.log(`[Dial-Complete] VA answered, ending normally`);
        return res.type('text/xml').send('<?xml version="1.0" encoding="UTF-8"?><Response><Hangup/></Response>');
    }

    // VA didn't answer - redirect to Eleven Labs
    console.log(`[Dial-Complete] VA missed call (${DialCallStatus}), redirecting to Eleven Labs`);

    const settings = await getTwilioSettings();
    const host = req.headers.host || 'localhost:5001';
    const httpProtocol = req.headers['x-forwarded-proto'] === 'https' ? 'https' : 'http';

    // Use routing engine to determine fallback
    const routingSettings: CallRoutingSettings = {
        agentMode: (settings.agentMode || 'auto') as AgentMode,
        forwardEnabled: settings.forwardEnabled,
        forwardNumber: settings.forwardNumber,
        fallbackAction: (settings.fallbackAction || 'voicemail') as FallbackAction,
        businessHoursStart: settings.businessHoursStart,
        businessHoursEnd: settings.businessHoursEnd,
        businessDays: settings.businessDays,
        elevenLabsAgentId: settings.elevenLabsAgentId,
        elevenLabsApiKey: settings.elevenLabsApiKey,
    };

    const routing = determineCallRouting(routingSettings, true); // isVAMissedCall = true
    console.log(`[Dial-Complete] Routing decision: ${routing.reason}`);

    let redirectUrl = `${httpProtocol}://${host}/api/twilio/voicemail`;

    if (routing.destination === 'eleven-labs' && routing.elevenLabsContext) {
        redirectUrl = `${httpProtocol}://${host}/api/twilio/eleven-labs-personal?agentId=${settings.elevenLabsAgentId}&leadPhoneNumber=${encodeURIComponent(leadNumber)}&context=${routing.elevenLabsContext}`;
    }

    console.log(`[Dial-Complete] Redirecting to: ${redirectUrl}`);

    // Return TwiML redirect (much cleaner than API update)
    const twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Redirect>${redirectUrl}</Redirect>
</Response>`;

    return res.type('text/xml').send(twiml);
});

// Twilio Dial Status Callback - (Legacy / Direct Dial Fallback)
// Kept for backward compatibility or if dynamic settings revert to simple Dial
app.post('/api/twilio/dial-status', async (req, res) => {
    const { DialCallStatus, From, CallSid } = req.body;
    console.log(`[Twilio] Dial status for ${CallSid}: ${DialCallStatus}`);

    const settings = await getTwilioSettings();
    const host = req.headers.host;
    const httpProtocol = req.headers['x-forwarded-proto'] === 'https' ? 'https' : 'http';

    // If call was not answered, trigger fallback
    if (DialCallStatus !== 'completed' && DialCallStatus !== 'answered') {
        console.log(`[Twilio] Call not answered, triggering fallback: ${settings.fallbackAction}`);

        // Send WhatsApp if enabled
        if (settings.fallbackAction === 'whatsapp' && From) {
            try {
                const fallbackMessage = (settings.fallbackMessage as string).replace('{business_name}', settings.businessName as string);
                // Use conversation engine to send message
                const { conversationEngine } = await import('./conversation-engine');
                await conversationEngine.sendMessage(From.replace('+', ''), fallbackMessage);
                console.log(`[Twilio] WhatsApp fallback sent to ${From}`);
            } catch (error) {
                console.error('[Twilio] Failed to send WhatsApp fallback:', error);
            }
        }

        // Play apology message and hang up
        const twiml = `<?xml version="1.0" encoding="UTF-8"?>
        <Response>
          <Say voice="${settings.voice}">Sorry we missed your call. We'll text you right back.</Say>
          <Hangup/>
        </Response>`;

        res.type('text/xml');
        res.send(twiml);
    } else {
        // Call was answered successfully - just end gracefully
        res.type('text/xml');
        res.send('<Response></Response>');
    }
});

// Twilio Recording Status Callback - Fallback transcription for calls with missing transcripts
import { transcribeFromUrl } from './deepgram';
import { calls } from '../shared/schema';
import { findCallByTwilioSid, updateCall, createCall } from './call-logger';

app.post('/api/twilio/recording-status', async (req, res) => {
    const { CallSid, RecordingSid, RecordingUrl, RecordingStatus } = req.body;
    console.log(`[Twilio] Recording status for ${CallSid}: ${RecordingStatus}`);

    // Respond immediately to Twilio
    res.status(200).send('OK');

    // Only process completed recordings
    if (RecordingStatus !== 'completed') {
        return;
    }

    try {
        // Find the call record by Twilio SID
        const callRecordId = await findCallByTwilioSid(CallSid);

        if (!callRecordId) {
            console.log(`[Recording] No call record found for ${CallSid}`);
            return;
        }

        // Get the call to check if it already has a transcript
        const [call] = await db.select({
            id: calls.id,
            transcription: calls.transcription,
            recordingUrl: calls.recordingUrl,
        }).from(calls).where(eq(calls.id, callRecordId));

        if (!call) {
            console.log(`[Recording] Call record ${callRecordId} not found`);
            return;
        }

        // Build the MP3 URL from the recording SID
        const accountSid = process.env.TWILIO_ACCOUNT_SID;
        const mp3Url = `https://api.twilio.com/2010-04-01/Accounts/${accountSid}/Recordings/${RecordingSid}.mp3`;

        // Always update the recording URL
        await updateCall(callRecordId, { recordingUrl: mp3Url });
        console.log(`[Recording] Updated call ${callRecordId} with recording URL`);

        // If transcription is missing or very short, trigger fallback transcription
        if (!call.transcription || call.transcription.length < 10) {
            console.log(`[Recording] Transcript missing/short for ${CallSid}, triggering fallback transcription...`);

            const transcript = await transcribeFromUrl(mp3Url);

            if (transcript) {
                await updateCall(callRecordId, { transcription: transcript });
                console.log(`[Recording] Fallback transcription saved for ${callRecordId} (${transcript.length} chars)`);
            } else {
                console.log(`[Recording] Fallback transcription failed for ${callRecordId}`);
            }
        } else {
            console.log(`[Recording] Call ${callRecordId} already has transcript (${call.transcription.length} chars)`);
        }

    } catch (error) {
        console.error('[Recording] Error processing recording status:', error);
    }
});

import { conversationEngine } from './conversation-engine';

// Create Server
const server = createServer(app);

// Setup WebSockets
const wssTwilio = new WebSocketServer({ noServer: true });
const wssClient = new WebSocketServer({ noServer: true });

export function broadcastToClients(message: any) {
    const data = JSON.stringify(message);
    wssClient.clients.forEach(client => {
        if (client.readyState === 1) { // WebSocket.OPEN
            client.send(data);
        }
    });
}

// Handle client WebSocket connections from frontend
wssClient.on('connection', (ws, req) => {
    console.log('[Client WS] Frontend client connected');
    console.log(`[Client WS] Total clients: ${wssClient.clients.size}`);

    ws.on('close', () => {
        console.log('[Client WS] Client disconnected');
        console.log(`[Client WS] Remaining clients: ${wssClient.clients.size}`);
    });

    ws.on('error', (error) => {
        console.error('[Client WS] WebSocket error:', error);
    });
});

setupTwilioSocket(wssTwilio, broadcastToClients);
conversationEngine.attachWebSocket(wssClient);

server.on('upgrade', (request, socket, head) => {
    const { pathname } = new URL(request.url || '', `http://${request.headers.host}`);
    console.log(`[Server] Upgrade request for ${pathname}`);

    if (pathname === '/api/twilio/realtime') {
        process.stdout.write('[Server] Upgrading to Twilio Realtime\n');
        wssTwilio.handleUpgrade(request, socket, head, (ws) => {
            wssTwilio.emit('connection', ws, request);
        });
    } else if (pathname === '/api/ws/client') {
        process.stdout.write('[Server] Upgrading to WhatsApp Client WS\n');
        wssClient.handleUpgrade(request, socket, head, (ws) => {
            wssClient.emit('connection', ws, request);
        });
    } else {
        process.stdout.write(`[Server] Unexpected upgrade for ${pathname} - destroying socket\n`);
        socket.destroy();
    }
});



async function startServer() {
    // Vite Middleware Setup
    if (process.env.NODE_ENV !== 'production') {
        try {
            const { createServer: createViteServer } = await import('vite');
            const vite = await createViteServer({
                server: { middlewareMode: true },
                appType: 'custom'
            });

            // Use vite's connect instance as middleware
            app.use(vite.middlewares);

            // Serve index.html for non-API routes only
            app.use('*', async (req, res, next) => {
                const url = req.originalUrl;

                // Skip API routes - they should be handled by API routers
                if (url.startsWith('/api')) {
                    return next();
                }

                try {
                    console.log(`[Vite SSR] Serving ${url}`);
                    let template = fs.readFileSync(path.resolve(__dirname, '../client/index.html'), 'utf-8');
                    template = await vite.transformIndexHtml(url, template);
                    res.status(200).set({ 'Content-Type': 'text/html' }).end(template);
                } catch (e) {
                    vite.ssrFixStacktrace(e as Error);
                    next(e);
                }
            });
            console.log("[V6 Switchboard] Vite middleware attached");
        } catch (e) {
            console.error("Failed to setup Vite middleware:", e);
        }
    } else {
        // Production
        app.use(express.static(path.resolve(__dirname, '../dist/public')));
        app.use('*', (req, res) => {
            res.sendFile(path.resolve(__dirname, '../dist/public/index.html'));
        });
    }

    // Start Listener
    const PORT = process.env.PORT || 5001;
    server.listen(PORT, async () => {
        console.log(`[V6 Switchboard] Listening on port ${PORT}`);
        console.log(`[V6 Switchboard] WebSocket at ws://localhost:${PORT}/api/twilio/realtime`);

        // B4: Preload SKU cache at startup
        console.log('[V6 Switchboard] Preloading SKU cache...');
        await loadAndCacheSkus();
        console.log('[V6 Switchboard] SKU cache ready');
    });
}

// execute start
startServer().catch(err => {
    console.error("Fatal error starting server:", err);
    process.exit(1);
});

// Handle EADDRINUSE at the process level for better DX
server.on('error', (e: any) => {
    if (e.code === 'EADDRINUSE') {
        console.log(`[V6 Switchboard] Port ${process.env.PORT || 5001} is in use.`);
        if (process.env.NODE_ENV !== 'production') {
            console.log('[V6 Switchboard] Dev mode detected: Attempting to kill the process occupying the port...');
            try {
                const port = process.env.PORT || 5001;
                const pid = execSync(`lsof -t -i:${port} -sTCP:LISTEN`).toString().trim();
                if (pid) {
                    process.kill(parseInt(pid), 'SIGKILL');
                    console.log(`[V6 Switchboard] Killed process ${pid}. Restarting server in 1s...`);
                    setTimeout(() => {
                        server.close();
                        server.listen(port);
                    }, 1000);
                    return;
                }
            } catch (err) {
                console.error('[V6 Switchboard] Failed to auto-kill process:', err);
            }
        }
        console.error(`[V6 Switchboard] Address in use, retrying...`);
        setTimeout(() => {
            server.close();
            server.listen(process.env.PORT || 5001);
        }, 1000);
    } else {
        console.error('[V6 Switchboard] Server error:', e);
    }
});

// Graceful shutdown handlers
process.on('SIGINT', async () => {
    console.log('\n[V6 Switchboard] Received SIGINT, shutting down gracefully...');
    conversationEngine.destroy();
    process.exit(0);
});

process.on('SIGTERM', async () => {
    console.log('\n[V6 Switchboard] Received SIGTERM, shutting down gracefully...');
    conversationEngine.destroy();
    process.exit(0);
});
